function X = LinearizeTrajectory(x,y,mazetype)
%
%
%

%%
    nbins = 100;

    switch mazetype
        case 'tmaze'
            %Get the boundaries, centroid, and length of the stem. 
            bounds = sections(x,y,1); 
            centroidx = mean(unique(bounds.center.x));
            centroidy = mean(unique(bounds.center.y));
            stemlength = bounds.center.x(2) - bounds.center.x(1); 
            
            %Convert from Cartesian coordinates to polar coordinates. 
            [angs,radii] = cart2pol(x-centroidx, y-centroidy); 
            angs = mod(angs,2*pi); 
           
            %Get timestamps for left and right trials and when mouse is on
            %stem. 
            Alt = postrials(x,y,0,'skip_rot_check',1);
            onstem = Alt.section==2; 
            
            %Get the extreme radii on the stem. 
            cosang = cos(angs);
            behind = onstem & cosang>0;
            ahead = onstem & cosang<0;
            maxback = max(radii(behind) .* cosang(behind)); 
            maxfront = -min(radii(ahead) .* cosang(ahead)); 

            %Create a polar definition of the maze based on the mean of the
            %radius at each angle bin. 
            angdef=(pi/nbins:2*pi/nbins:2*pi)';
            sparseang = [angs(~onstem)'; 0; pi];
            sparserad = [radii(~onstem)'; maxback; maxfront]; 
            [~,angidx] = histc(sparseang,linspace(0,2*pi,nbins));
            meanrad = accumarray(angidx,sparserad,[nbins,1],@mean);
            mazedef = [meanrad((round(nbins/2)+1):nbins); meanrad; ...
                meanrad(1:round(nbins/2))]; 
            
            %Smooth the vector of radii.  
            mazedef = smooth(mazedef,10,'rlowess'); 
            mazedef = mazedef((round(nbins/2)+1):round(nbins/2)+nbins);
            
            %Build angdef vector from 0 to 2pi. The first and last elements
            %of mazedef are the extrema of the maze. Take the mean of them
            %and pad onto the extreme angles. Now it corresponds to the
            %linearized distance based off angdef. 
            mazedef = [mean(mazedef([1 end])); mazedef; mean(mazedef([1 end]))];
            angdef = [0; angdef; 2*pi]; 
            
            %Find the cumulative distances to build look-up table. 
            rightside=angdef<=pi;   %Right turns on top given our viewing angle.
            leftside=angdef>=pi;
            [l_x,l_y]=pol2cart(angdef(leftside),mazedef(leftside));
            [r_x,r_y]=pol2cart(angdef(rightside),mazedef(rightside));
            
            %Use hypot to get the distance between points. 
            leftdist=[0; cumsum(hypot(diff(l_x),diff(l_y)))];   
            rightdist=[0; cumsum(hypot(diff(r_x),diff(r_y)))];
            
            %Create radian-ordered cumulative distance look-up table.
            cumdist(leftside) = leftdist; 
            cumdist(rightside) = flip(rightdist);   %Right turns go in reverse order. 
            cumdist = cumdist + stemlength; 
            
            %Find linearized distance for all tracking by interpolation. 
            X=interp1(angdef,cumdist,angs,'pchip');
            
            %Use ra
            X(onstem) = maxback + radii(onstem) .* -cosang(onstem);
            X(X(onstem)<0) = 0;
            X(X(onstem)>stemlength) = stemlength;
            
            keyboard;
        %To do.
        case 'loop'
            disp('Loop code not finished yet!'); 
    end
    
end